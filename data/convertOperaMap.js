import fs from 'fs';
import path from 'path';

// Usage:
// node data/convertOperaMap.js <mapPath> <assetUrl> [sheetPngPath | tilesetpxw tilesetpxh]
//
// Examples:
// 1) Auto-read PNG size:
//    node data/convertOperaMap.js data/maps/opera/map.json /assets/opera.png data/maps/opera/spritesheet.png
// 2) Provide pixel dimensions explicitly:
//    node data/convertOperaMap.js data/maps/opera/map.json /assets/opera.png 2048 8192

function fail(msg) {
  console.error(msg);
  process.exit(1);
}

function readJson(file) {
  try {
    return JSON.parse(fs.readFileSync(file, 'utf8'));
  } catch (e) {
    fail(`Failed to read JSON "${file}": ${e.message}`);
  }
}

function isNumberString(s) {
  return typeof s === 'string' && /^[0-9]+$/.test(s);
}

// Read PNG dimensions without extra deps.
// Ref: PNG signature and IHDR chunk (width/height big-endian at bytes 16-23)
function readPngDimensions(pngPath) {
  const buf = fs.readFileSync(pngPath);
  const pngSig = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
  if (buf.length < 24 || !buf.subarray(0, 8).equals(pngSig)) {
    fail(`"${pngPath}" is not a valid PNG file or too small to read.`);
  }
  const width = buf.readUInt32BE(16);
  const height = buf.readUInt32BE(20);
  return { width, height };
}

function makeLayerGrid(width, height, fill = -1) {
  const grid = new Array(width);
  for (let x = 0; x < width; x++) {
    const col = new Array(height);
    for (let y = 0; y < height; y++) col[y] = fill;
    grid[x] = col;
  }
  return grid;
}

function convertOperaJson(operaJson) {
  // Expecting format like:
  // { tileSize, mapWidth, mapHeight, layers: [ { name, tiles: [{id,x,y}, ...] } ] }
  const tileDim = operaJson.tileSize;
  const width = operaJson.mapWidth;
  const height = operaJson.mapHeight;
  if (
    typeof tileDim !== 'number' ||
    typeof width !== 'number' ||
    typeof height !== 'number' ||
    !Array.isArray(operaJson.layers)
  ) {
    fail('Input JSON is not in the expected opera format (tileSize, mapWidth, mapHeight, layers[]).');
  }

  function layerByName(name) {
    return operaJson.layers.find((l) => l && l.name === name);
  }

  function toEngineLayer(name) {
    const layer = layerByName(name);
    const grid = makeLayerGrid(width, height, -1);
    if (layer && Array.isArray(layer.tiles)) {
      for (const t of layer.tiles) {
        // Ensure numeric indices
        const id = Number(t.id);
        const x = Number(t.x);
        const y = Number(t.y);
        if (
          Number.isFinite(id) &&
          Number.isFinite(x) &&
          Number.isFinite(y) &&
          x >= 0 &&
          x < width &&
          y >= 0 &&
          y < height
        ) {
          grid[x][y] = id;
        }
      }
    }
    // Engine expects an array of layers; wrap single grid in an array.
    return [grid];
  }

  const bgtiles = toEngineLayer('bgtiles');
  const objmap = toEngineLayer('objmap');

  return { tileDim, width, height, bgtiles, objmap };
}

function main() {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    fail(
      'Usage: node data/convertOperaMap.js <mapPath> <assetUrl> [sheetPngPath | tilesetpxw tilesetpxh]'
    );
  }
  const [mapPath, assetUrl, third, fourth] = args;
  if (!fs.existsSync(mapPath)) {
    fail(`Map JSON not found: ${mapPath}`);
  }
  if (typeof assetUrl !== 'string' || !assetUrl.startsWith('/')) {
    fail('assetUrl must be a web-served URL path like "/assets/opera.png"');
  }

  let tilesetpxw;
  let tilesetpxh;

  if (third && fourth && isNumberString(third) && isNumberString(fourth)) {
    tilesetpxw = parseInt(third, 10);
    tilesetpxh = parseInt(fourth, 10);
  } else {
    // Try to read PNG path from arg3, else infer from public folder + assetUrl
    let pngPath = third;
    if (!pngPath) {
      // Try to find in public directory relative to repo root
      pngPath = path.join(process.cwd(), 'public', assetUrl);
    } else if (!path.isAbsolute(pngPath)) {
      pngPath = path.join(process.cwd(), pngPath);
    }
    if (!fs.existsSync(pngPath)) {
      fail(
        `Could not determine PNG path for dimension detection.\n` +
          `Provide it as arg3, or pass explicit pixel dimensions. Tried: ${pngPath}`
      );
    }
    const { width, height } = readPngDimensions(pngPath);
    tilesetpxw = width;
    tilesetpxh = height;
  }

  const operaJson = readJson(mapPath);
  const converted = convertOperaJson(operaJson);

  const out =
`// Map generated by convertOperaMap.js

export const tilesetpath = "${assetUrl}";
export const tiledim = ${converted.tileDim};
export const screenxtiles = ${converted.width};
export const screenytiles = ${converted.height};
export const tilesetpxw = ${tilesetpxw};
export const tilesetpxh = ${tilesetpxh};

export const bgtiles = ${JSON.stringify(converted.bgtiles)};
export const objmap = ${JSON.stringify(converted.objmap)};
export const animatedsprites = [];
export const mapwidth = ${converted.width};
export const mapheight = ${converted.height};
`;

  fs.writeFileSync('converted-map.js', out);
  console.log('Map conversion complete: wrote converted-map.js');
}

main();


